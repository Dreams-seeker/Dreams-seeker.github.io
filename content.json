{"meta":{"title":"曾忆往昔","subtitle":"悟","description":"生活很苦,但是生活从不是只针对一个人,每个人都经历过一段异常艰苦的时光","author":"曹晗","url":"http://hanusers.gitee.io"},"pages":[{"title":"关于我","date":"2018-03-23T10:12:29.000Z","updated":"2018-11-01T08:28:57.122Z","comments":true,"path":"about/index.html","permalink":"http://hanusers.gitee.io/about/index.html","excerpt":"","text":"一只不断学习的IT人，欢迎分享知识。作者:曹晗QQ号:1525629557 说 没有人会为你的贫穷负责,却有人为你的富有而喝彩!所以不要活在别人的嘴巴里、做好自己！有路，就大胆的去走；有梦，就大胆的飞翔；若要成功，就要大胆去闯。大胆尝试才是信仰。不敢做，梦想就会变成幻想。前行的路，不怕万人阻挡，只怕自己投降；人生的帆，不怕狂风巨浪，只怕自己没胆量！天道酬勤，人道酬善，商道酬信，业道酬精！ –习近平"},{"title":"archives","date":"2018-10-19T07:24:09.000Z","updated":"2018-10-19T07:24:56.125Z","comments":true,"path":"archives/index.html","permalink":"http://hanusers.gitee.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-19T07:18:55.000Z","updated":"2018-10-19T07:19:35.206Z","comments":true,"path":"categories/index.html","permalink":"http://hanusers.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-10T10:23:38.000Z","updated":"2018-09-28T09:16:38.265Z","comments":true,"path":"tags/index.html","permalink":"http://hanusers.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"重构-改善既有代码的设计","slug":"Refactoring","date":"2018-09-30T06:06:19.000Z","updated":"2018-11-01T05:59:50.411Z","comments":true,"path":"2018/09/30/Refactoring/","link":"","permalink":"http://hanusers.gitee.io/2018/09/30/Refactoring/","excerpt":"","text":"一、什么是重构? 所谓重构（refactoring）是这样一个过程:在不改变代码外在行为的前提下,对代码做出修改,以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度的减少整理过程中引入错误的几率。本质上说，重构就是在代码写好之后改进它的设计。 在代码写好之后改进它的设计”？这种说法有些奇怪。按照目前对软件开发的理解，我们相信应该先设计后编码：首先得有一个良好的设计，然后才能开发编码。但是，随着时间流逝，人们不断修改代码于是根据原先设计所得的系统，整体结构逐渐衰弱。代码质量慢慢沉沦，编码工作从严谨的工程堕落为胡砍乱劈的随性行为。 重构 正好与此相反,哪怕你手上有一个糟糕的设计，甚至是一堆混乱的代码，你也可以借由重构将它设计良好的代码，重构的每个步骤都很简单，甚至显的过于简单：你只需要把某个字段从一个类移到另一个类，把某些代码从一个函数拉出来构成另一个函数，或是在继承体系中把某些代码推上推下就行了。但是，聚沙成塔，这些小小的累积起来就可以根本改善设计质量。这和一般常见的软件会慢慢腐烂”的观点恰恰相反。 通过重构你可以找到改变的平衡点。你会发现所谓设计不再是一切动作的前提，而是在整个开发过程中逐渐浮现出来。在系统构筑过程中，你可以学习如何强化设计，其间带来的互动可以让一个程序在开发过程中持续保有良好的设计。","categories":[{"name":"重构","slug":"重构","permalink":"http://hanusers.gitee.io/categories/重构/"}],"tags":[{"name":"重构","slug":"重构","permalink":"http://hanusers.gitee.io/tags/重构/"}]},{"title":"JS的异步事件和轮询机制","slug":"jsPolling","date":"2018-09-14T07:09:50.000Z","updated":"2018-10-19T09:52:54.586Z","comments":true,"path":"2018/09/14/jsPolling/","link":"","permalink":"http://hanusers.gitee.io/2018/09/14/jsPolling/","excerpt":"","text":"一、JS为何是单线程的？ JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。（在JAVA和c#中的异步均是通过多线程实现的，没有循环队列一说，直接在子线程中完成相关的操作） JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。 这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 二、JS是单线程的，那么他是如何是实现异步操作的？ JS的异步是通过回调函数实现的，即通过任务队列，在主线程执行完当前的任务栈（所有的同步操作），主线程空闲后轮询任务队列，并将任务队列中的任务（回调函数）取出来执行。”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。(该过程又称之为事件轮询) 三、JS种事件队列的优先级 在JS中ES6 中新增的任务队列（promise）是在事件循环之上的，事件循环每次 tick 后会查看 ES6 的任务队列中是否有任务要执行，也就是 ES6 的任务队列比事件循环中的任务（事件）队列优先级更高。 如 Promise 就使用了 ES6 的任务队列特性。也即在执行完任务栈后首先执行的是任务队列中的promise任务。其他的上面常见的异步操作加入队列的时间没有相应的优先级。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hanusers.gitee.io/categories/JavaScript/"}],"tags":[{"name":"JS的异步事件和轮询机制","slug":"JS的异步事件和轮询机制","permalink":"http://hanusers.gitee.io/tags/JS的异步事件和轮询机制/"}]},{"title":"自定义注解","slug":"annotation","date":"2018-07-17T09:51:41.000Z","updated":"2018-10-19T08:23:46.738Z","comments":true,"path":"2018/07/17/annotation/","link":"","permalink":"http://hanusers.gitee.io/2018/07/17/annotation/","excerpt":"","text":"JAVA中的注解以及自定义注解 什么是注解? 注解的用处? 注解的原理? 元注解? 常见标准的Annotation? 自定义注解? 自定义注解实例? 百度百科 注解基础知识点 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 作用分类： ①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 ② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 ③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 一、什么是注解?JAVA注解 Annotation(注解)是 JDK1.5 及以后版本引入的。中它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射机制编程实现对这些元数据（用来描述数据的数据）的访问。另外，你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。 Annotation是JAVA5开始引入的一种新特征,中文名称叫做注解。它提供了一种安全的类似似注释的机制，用于将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联，为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，并且供指定的工具或框架使用，Annontation像一种修饰符一样，应用于包、类型、构造方法，方法、成员变量、参数及本地变量的声明语句中。Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能，注解不会也不能影响代码的实际逻辑仅仅起到辅助的作用。包含java.lang.annotation包中。 二、注解的用处？ 1 .生成文档，这是最常见的，也是java最早提供的注解。常用的有@param @return等。 2 .跟踪代码依赖性，实现替代配置文件功能，比如Dagger2 依赖注入，未来java开发，将大量注解配置，具有很大好处。 3 .在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。 三、注解的原理? 注解的本质是一个继承了Annotation的特殊接口，其具体实现类是JAVA运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。 四、元注解? java.lang.annotation提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要用到元注解）：@Documented 注解是否将包含在javaDoc中@Retention –什么时候使用该注解@Target –注解用于什么地方@Inherited – 是否允许子类继承该注解 1.）@Retention– 定义该注解的生命周期 ● RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 ● RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式 ● RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 2.）Target – 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType参数包括 ● ElementType.CONSTRUCTOR:用于描述构造器 ● ElementType.FIELD:成员变量、对象、属性（包括enum实例） ● ElementType.LOCAL_VARIABLE:用于描述局部变量 ● ElementType.METHOD:用于描述方法 ● ElementType.PACKAGE:用于描述包 ● ElementType.PARAMETER:用于描述参数 ● ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明 3.)@Documented–一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。 4.)@Inherited – 定义该注释和子类的关系 @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 五、常见标准的Annotation：1.）Override java.lang.Override是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。 2.）Deprecated Deprecated也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员， 虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。 3.)SuppressWarnings SuppressWarning不是一个标记类型注解。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。 @SuppressWarnings(&quot;unchecked&quot;) 六、自定义注解?自定义注解类编写的一些规则: 1. Annotation型定义为@interface, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口. 2. 参数成员只能用public或默认(default)这两个访问权修饰 3. 参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String、Enum、Class、annotations等数据类型,以及这一些类型的数组. 4. 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法 5. 注解也可以没有定义成员, 不过这样注解就没啥用了 PS:自定义注解需要使用到元注解 七、自定义注解实例？ FruitName:java","categories":[{"name":"Java","slug":"Java","permalink":"http://hanusers.gitee.io/categories/Java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://hanusers.gitee.io/tags/注解/"}]},{"title":"SpringBoot","slug":"springboot","date":"2018-07-16T09:39:37.000Z","updated":"2018-10-19T08:21:56.403Z","comments":true,"path":"2018/07/16/springboot/","link":"","permalink":"http://hanusers.gitee.io/2018/07/16/springboot/","excerpt":"","text":"SpringBoot概述 Build Anything with Spring Boot：Spring Boot is the starting point for building all Spring-based applications.Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring. 上面是引自Spring官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。 追问一: SpringBoot是什么，它可以做什么? 在过去的两年时间里，最让人兴奋、回头率最高、最能改变游戏规则的东西，大概就是Spring Boot了。Spring Boot提供了一种新的编程范式，能在最小的阻力下开发Spring应用程序。有了它， 你可以更加敏捷地开发Spring应用程序，专注于应用程序的功能，不用在Spring的配置上多花功夫，甚至完全不用配置。实际上，Spring Boot的一项重要工作就是让Spring配置不再成为你成功路上的绊脚石。 搜狗百科 Spring Boot Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者 SpringBoot的一些解释SpringBoot与SpringMvc的关系:SpringBoot是SpringMvc的升级版，抛弃掉SpringMvc的大量的xml中的配置项. SpringBoot的一些特点. 1.化繁为简，简化配置. 2.备受关注,是下一代框架. 3.微服务的入门级微框架，（微服务:SpringCloud）Spring家族的微服务。Spring-Data-Jpa: JPA(java persistence API):定义了一系列对象持久化的标准，目前实现这一规范的产品有Hibernate TopLink等 SpringBoot项目整体结构图一:图二:","categories":[{"name":"Java","slug":"Java","permalink":"http://hanusers.gitee.io/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://hanusers.gitee.io/tags/SpringBoot/"}]},{"title":"介绍Spring","slug":"20180712001","date":"2018-07-12T06:39:15.000Z","updated":"2018-10-19T08:23:46.364Z","comments":true,"path":"2018/07/12/20180712001/","link":"","permalink":"http://hanusers.gitee.io/2018/07/12/20180712001/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"http://hanusers.gitee.io/categories/Java/"}],"tags":[{"name":"First","slug":"First","permalink":"http://hanusers.gitee.io/tags/First/"},{"name":"Second","slug":"Second","permalink":"http://hanusers.gitee.io/tags/Second/"}]}]}