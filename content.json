{"meta":{"title":"CH的BLOG","subtitle":"悟","description":"生活很苦,但是生活从不是只针对一个人,每个人都经历过一段异常艰苦的时光","author":"曹晗","url":"http://hanusers.gitee.io"},"pages":[{"title":"关于我","date":"2018-03-23T10:12:29.000Z","updated":"2018-11-01T08:28:57.122Z","comments":true,"path":"about/index.html","permalink":"http://hanusers.gitee.io/about/index.html","excerpt":"","text":"一只不断学习的IT人，欢迎分享知识。作者:曹晗QQ号:1525629557 说 没有人会为你的贫穷负责,却有人为你的富有而喝彩!所以不要活在别人的嘴巴里、做好自己！有路，就大胆的去走；有梦，就大胆的飞翔；若要成功，就要大胆去闯。大胆尝试才是信仰。不敢做，梦想就会变成幻想。前行的路，不怕万人阻挡，只怕自己投降；人生的帆，不怕狂风巨浪，只怕自己没胆量！天道酬勤，人道酬善，商道酬信，业道酬精！ –习近平"},{"title":"archives","date":"2018-10-19T07:24:09.000Z","updated":"2018-10-19T07:24:56.125Z","comments":true,"path":"archives/index.html","permalink":"http://hanusers.gitee.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-19T07:18:55.000Z","updated":"2018-10-19T07:19:35.206Z","comments":true,"path":"categories/index.html","permalink":"http://hanusers.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-10T10:23:38.000Z","updated":"2018-09-28T09:16:38.265Z","comments":true,"path":"tags/index.html","permalink":"http://hanusers.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM内存模型","slug":"JVM","date":"2021-06-02T07:59:02.000Z","updated":"2021-06-08T02:13:17.503Z","comments":true,"path":"2021/06/02/JVM/","link":"","permalink":"http://hanusers.gitee.io/2021/06/02/JVM/","excerpt":"","text":"JVM内存模型 jvm 内存模型划分根据JVM规范，JVM 内存共分为虚拟机栈，堆，方法区，程序计数器，本地方法栈五个部分。 程序计数器(线程私有)：是当前线程锁执行字节码的行号治时期，每条线程都有一个独立的程序计数器，这类内存也称为“线程私有”的内存。正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。如果是Natice方法，则为空 Java 虚拟机栈也是线程私有的。每个方法在执行的时候也会创建一个栈帧，存储了局部变量，操作数，动态链接，方法返回地址。每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。通常所说的栈，一般是指在虚拟机栈中的局部变量部分。局部变量所需内存在编译期间完成分配，如果线程请求的栈深度大于虚拟机所允许的深度，则StackOverflowError。如果虚拟机栈可以动态扩展，扩展到无法申请足够的内存，则OutOfMemoryError。 本地方法栈（线程私有）和虚拟机栈类似，主要为虚拟机使用到的Native方法服务。也会抛出StackOverflowError 和OutOfMemoryError。 Java堆（线程共享）被所有线程共享的一块内存区域，在虚拟机启动的时候创建，用于存放对象实例。对可以按照可扩展来实现（通过-Xmx 和-Xms 来控制）当队中没有内存可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。 方法区（线程共享）被所有方法线程共享的一块内存区域。用于存储已经被虚拟机加载的类信息，常量，静态变量等。这个区域的内存回收目标主要针对常量池的回收和堆类型的卸载。 .jvm 1.8 内存区域划分 程序计数器 每个线程一块内存，指向当前正在执行的字节码的行号。如果当前线程是native方法，则其值为null。 ps(程序计数器内存划分)因为处理器在一个确定是时刻只会执行一个线程中的指令，线程切换后，是通过计数器来记录执行痕迹的，因而可以看出，程序计数器是每个线程私有的。如果执行的是java方法，那么记录的是正在执行的虚拟机字节码指令的地址的地址，如果是native方法，计数器的值为空 Java虚拟机栈 java堆: 对于大多数应用来说,java堆(Java Heap)是java虚拟机所管理的内存中最大的一块,java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建,此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存. 堆是垃圾收集器管理的主要区域,因此很多时间也被称作”GC堆”(Garbage Collected Heap),从内存回收的角度看,由于现在收集器都采用分代收集算法,所以java堆中还可以细分为: 新生代和老年代,再细致一点的有Eden空间、From Survivor空间、To Survivor空间等，从内存分配的角度来看，线程共享的java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer Tlab）java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，当前主流的虚拟机都是按照可扩展来实现的。 未完，待续。。。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://hanusers.gitee.io/categories/JVM/"}],"tags":[{"name":"JVM虚拟机原理","slug":"JVM虚拟机原理","permalink":"http://hanusers.gitee.io/tags/JVM虚拟机原理/"}]},{"title":"JWT","slug":"JWT","date":"2021-06-02T07:59:02.000Z","updated":"2021-06-08T09:01:48.185Z","comments":true,"path":"2021/06/02/JWT/","link":"","permalink":"http://hanusers.gitee.io/2021/06/02/JWT/","excerpt":"","text":"JWTJSON Web Token(JWT) 是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的消息。 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷、与签名。 JWT 校验 头部（Header） 头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。 {\"typ\":\"JWT\",\"alg\":\"HS256\"} 在头部指明了签名算法是HS256算法。 我们进行BASE64编码http://base64.xpcha.com/，编码后的字符串如下： eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 载荷（playload） 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 （1）标准中注册的声明（建议但不强制使用） iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token。 （2）公共的声明 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密. （3）私有的声明 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 这个指的就是自定义的claim。比如前面那个结构举例中的admin和name都属于自定的claim。这些claim跟JWT标准规定的claim区别在于：JWT规定的claim，JWT的接收方在拿到JWT之后， 都知道怎么对这些标准的claim进行验证(还不知道是否能够验证)；而private claims不会验证，除非明确告诉接收方要对这些claim进行验证以及规则才行。 定义一个payload: {\"sub\":\"1234567890\",\"name\":\"John Doe\",\"admin\":true} 然后将其进行base64加密，得到Jwt的第二部分。 eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 签证（signature） jwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。 JWT签发与验证tokenJWT是一个提供端到端的JWT创建和验证的Java库。永远免费和开源(Apache License，版本2.0)，JWT很容易使用和理解。它被设计成一个以建筑为中心的流畅界面，隐藏了它的大部分复杂性。 官方文档： https://github.com/jwtk/jjwt 创建token（1）新建项目中的pom.xml中添加依赖： &lt;dependency> &lt;groupId>io.jsonwebtoken&lt;/groupId> &lt;artifactId>jjwt&lt;/artifactId> &lt;version>0.9.0&lt;/version> &lt;/dependency> （2）创建测试类，代码如下 JwtBuilder builder= Jwts.builder() .setId(\"888\") //设置唯一编号 .setSubject(\"小白\")//设置主题 可以是JSON数据 .setIssuedAt(new Date())//设置签发日期 .signWith(SignatureAlgorithm.HS256,\"hahaha\");//设置签名 使用HS256算法，并设置SecretKey(字符串) //构建 并返回一个字符串 System.out.println( builder.compact() ); 运行打印结果： eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1NTc5MDQxODF9.ThecMfgYjtoys3JX7dpx3hu6pUm0piZ0tXXreFU_u3Y 再次运行，会发现每次运行的结果是不一样的，因为我们的载荷中包含了时间。 解析token我们刚才已经创建了token ，在web应用中这个操作是由服务端进行然后发给客户端，客户端在下次向服务端发送请求时需要携带这个token（这就好像是拿着一张门票一样），那服务端接到这个token 应该解析出token中的信息（例如用户id）,根据这些信息查询数据库返回相应的结果。 String compactJwt=\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1NTc5MDQxODF9.ThecMfgYjtoys3JX7dpx3hu6pUm0piZ0tXXreFU_u3Y\"; Claims claims = Jwts.parser().setSigningKey(\"hahaha\").parseClaimsJws(compactJwt).getBody(); System.out.println(claims); 运行打印效果：{jti=888, sub=小白, iat=1557904181} 试着将token或签名秘钥篡改一下，会发现运行时就会报错，所以解析token也就是验证token. 设置过期时间有很多时候，我们并不希望签发的token是永久生效的，所以我们可以为token添加一个过期时间。 （1）创建token 并设置过期时间 long now=System.currentTimeMillis(); long exp=now+1000*30;//30秒过期 JwtBuilder jwtBuilder = Jwts.builder().setId( \"888\" ) .setSubject( \"小白\" ) .setIssuedAt( new Date() )//签发时间 .setExpiration( new Date( exp ) )//过期时间 .signWith( SignatureAlgorithm.HS256, \"hahaha\" ); String token = jwtBuilder.compact(); System.out.println(token); 运行，打印效果如下： eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1NTc5MDUzMDgsImV4cCI6MTU1NzkwNTMwOH0.4q5AaTyBRf8SB9B3Tl-I53PrILGyicJC3fgR3gWbvUI （2）解析TOKEN String compactJwt=\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1NTc5MDUzMDgsImV4cCI6MTU1NzkwNTMwOH0.4q5AaTyBRf8SB9B3Tl-I53PrILGyicJC3fgR3gWbvUI\"; Claims claims = Jwts.parser().setSigningKey(\"hahaha\").parseClaimsJws(compactJwt).getBody(); System.out.println(claims); 当前时间超过过期时间，则会报错。 自定义claims我们刚才的例子只是存储了id和subject两个信息，如果你想存储更多的信息（例如角色）可以定义自定义claims。 long now=System.currentTimeMillis(); long exp=now+1000*30;//30秒过期 JwtBuilder jwtBuilder = Jwts.builder().setId( \"888\" ) .setSubject( \"小白\" ) .setIssuedAt( new Date() )//签发时间 .setExpiration( new Date( exp ) )//过期时间 .claim( \"roles\",\"admin\" ) .signWith( SignatureAlgorithm.HS256, \"hahaha\" ); String token = jwtBuilder.compact(); System.out.println(token); 运行打印效果： eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1NTc5MDU4MDIsImV4cCI6MTU1NzkwNjgwMiwicm9sZXMiOiJhZG1pbiJ9.AS5Y2fNCwUzQQxXh_QQWMpaB75YqfuK-2P7VZiCXEJI 解析TOKEN: String token =\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1NjIyNTM3NTQsImV4cCI6MTU2MjI1Mzc4Mywicm9sZXMiOiJhZG1pbiJ9.CY6CMembCi3mAkBHS3ivzB5w9uvtZim1HkizRu2gWaI\"; Claims claims = Jwts.parser().setSigningKey( \"hahaha\" ).parseClaimsJws( token ).getBody(); System.out.println(claims); System.out.println(claims.get( \"roles\" ));","categories":[{"name":"安全加密","slug":"安全加密","permalink":"http://hanusers.gitee.io/categories/安全加密/"}],"tags":[{"name":"安全加密","slug":"安全加密","permalink":"http://hanusers.gitee.io/tags/安全加密/"}]},{"title":"Oracle去重","slug":"SQL001","date":"2018-12-03T06:15:23.000Z","updated":"2018-12-03T06:49:09.148Z","comments":true,"path":"2018/12/03/SQL001/","link":"","permalink":"http://hanusers.gitee.io/2018/12/03/SQL001/","excerpt":"","text":"简介 最近在项目中遇到了Oracle去重的问题,这种问题其实在项目中是经常见到的.小编整理的去重的几种方法,做下记录: 一. 利用伪列和group by删除重复数据.delete from wms_oms_inbound d where d.inboundkey in (select l.inboundkey from wms_oms_inbound l group by l.inboundkey having count(l.inboundkey) &gt; 5) and rowid not in (select min(rowid) from wms_oms_inbound n group by n.inboundkey having count(n.inboundkey) &gt; 5) 以上是删除表中多余的重复记录，重复记录是根据单个字段（inboundkey）来判断，只留有rowid最小的记录.利用了oracle数据库的伪列进行删除的. 二. 查找表中多余的重复记录（多个字段），不包含rowid最小的记录","categories":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://hanusers.gitee.io/categories/Oracle数据库/"}],"tags":[{"name":"Oracle数据库","slug":"Oracle数据库","permalink":"http://hanusers.gitee.io/tags/Oracle数据库/"}]},{"title":"Git初识","slug":"Gita","date":"2018-11-27T08:37:08.000Z","updated":"2021-06-08T00:36:38.246Z","comments":true,"path":"2018/11/27/Gita/","link":"","permalink":"http://hanusers.gitee.io/2018/11/27/Gita/","excerpt":"","text":"git Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 Git 与 SVN 区别Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。 如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。 Git 与 SVN 区别点： 1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。 2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。 3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。 4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。 5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://hanusers.gitee.io/tags/Git/"}]},{"title":"BigData","slug":"BigData","date":"2018-11-27T07:59:02.000Z","updated":"2018-12-03T08:34:46.402Z","comments":true,"path":"2018/11/27/BigData/","link":"","permalink":"http://hanusers.gitee.io/2018/11/27/BigData/","excerpt":"","text":"一 、大数据初识大数据组件分类* ETL * 流式计算 *Flume、Sqoop * Spark Streaming * Nosql数据库 * 工作流 * HBase * Oozie * SQL on Hadoop * 资源管理 * Hive、Phoenix * Yarn、Zookeeper * 内存计算 * 安全 * Spark * Access、Kerbores *消息队列 * 监控 * Kafka * Ganglia 学习资料 Definitive Guide系列 In Action系列推荐读物","categories":[{"name":"大数据","slug":"大数据","permalink":"http://hanusers.gitee.io/categories/大数据/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://hanusers.gitee.io/tags/大数据/"}]},{"title":"重构-改善既有代码的设计","slug":"Refactoring","date":"2018-09-30T06:06:19.000Z","updated":"2021-06-02T09:14:54.215Z","comments":true,"path":"2018/09/30/Refactoring/","link":"","permalink":"http://hanusers.gitee.io/2018/09/30/Refactoring/","excerpt":"","text":"一、什么是重构? 所谓重构（refactoring）是这样一个过程:在不改变代码外在行为的前提下,对代码做出修改,以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度的减少整理过程中引入错误的几率。本质上说，重构就是在代码写好之后改进它的设计。 在代码写好之后改进它的设计”？这种说法有些奇怪。按照目前对软件开发的理解，我们相信应该先设计后编码：首先得有一个良好的设计，然后才能开发编码。但是，随着时间流逝，人们不断修改代码于是根据原先设计所得的系统，整体结构逐渐衰弱。代码质量慢慢沉沦，编码工作从严谨的工程堕落为胡砍乱劈的随性行为。 重 构正好与此相反,哪怕你手上有一个糟糕的设计，甚至是一堆混乱的代码，你也可以借由重构将它设计良好的代码，重构的每个步骤都很简单，甚至显的过于简单：你只需要把某个字段从一个类移到另一个类，把某些代码从一个函数拉出来构成另一个函数，或是在继承体系中把某些代码推上推下就行了。但是，聚沙成塔，这些小小的累积起来就可以根本改善设计质量。这和一般常见的软件会慢慢腐烂”的观点恰恰相反。 通过重构你可以找到改变的平衡点。你会发现所谓设计不再是一切动作的前提，而是在整个开发过程中逐渐浮现出来。在系统构筑过程中，你可以学习如何强化设计，其间带来的互动可以让一个程序在开发过程中持续保有良好的设计。","categories":[{"name":"重构","slug":"重构","permalink":"http://hanusers.gitee.io/categories/重构/"}],"tags":[{"name":"重构","slug":"重构","permalink":"http://hanusers.gitee.io/tags/重构/"}]},{"title":"JS的异步事件和轮询机制","slug":"jsPolling","date":"2018-09-14T07:09:50.000Z","updated":"2018-10-19T09:52:54.586Z","comments":true,"path":"2018/09/14/jsPolling/","link":"","permalink":"http://hanusers.gitee.io/2018/09/14/jsPolling/","excerpt":"","text":"一、JS为何是单线程的？ JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。（在JAVA和c#中的异步均是通过多线程实现的，没有循环队列一说，直接在子线程中完成相关的操作） JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。 这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 二、JS是单线程的，那么他是如何是实现异步操作的？ JS的异步是通过回调函数实现的，即通过任务队列，在主线程执行完当前的任务栈（所有的同步操作），主线程空闲后轮询任务队列，并将任务队列中的任务（回调函数）取出来执行。”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。(该过程又称之为事件轮询) 三、JS种事件队列的优先级 在JS中ES6 中新增的任务队列（promise）是在事件循环之上的，事件循环每次 tick 后会查看 ES6 的任务队列中是否有任务要执行，也就是 ES6 的任务队列比事件循环中的任务（事件）队列优先级更高。 如 Promise 就使用了 ES6 的任务队列特性。也即在执行完任务栈后首先执行的是任务队列中的promise任务。其他的上面常见的异步操作加入队列的时间没有相应的优先级。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hanusers.gitee.io/categories/JavaScript/"}],"tags":[{"name":"JS的异步事件和轮询机制","slug":"JS的异步事件和轮询机制","permalink":"http://hanusers.gitee.io/tags/JS的异步事件和轮询机制/"}]},{"title":"自定义注解","slug":"annotation","date":"2018-07-17T09:51:41.000Z","updated":"2021-06-02T08:13:37.752Z","comments":true,"path":"2018/07/17/annotation/","link":"","permalink":"http://hanusers.gitee.io/2018/07/17/annotation/","excerpt":"","text":"JAVA中的注解以及自定义注解 什么是注解? 注解的用处? 注解的原理? 元注解? 常见标准的Annotation? 自定义注解? 自定义注解实例? 百度百科 注解基础知识点 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 作用分类： ①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 ② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 ③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 一、什么是注解?JAVA注解 Annotation(注解)是 JDK1.5 及以后版本引入的。中它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。注解是以‘@注解名’在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射机制编程实现对这些元数据（用来描述数据的数据）的访问。另外，你可以在编译时选择代码里的注解是否只存在于源代码级，或者它也能在class文件、或者运行时中出现（SOURCE/CLASS/RUNTIME）。 Annotation是JAVA5开始引入的一种新特征,中文名称叫做注解。它提供了一种安全的类似似注释的机制，用于将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联，为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息与程序的业务逻辑无关，并且供指定的工具或框架使用，Annontation像一种修饰符一样，应用于包、类型、构造方法，方法、成员变量、参数及本地变量的声明语句中。Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能，注解不会也不能影响代码的实际逻辑仅仅起到辅助的作用。包含java.lang.annotation包中。 二、注解的用处？ 1 .生成文档，这是最常见的，也是java最早提供的注解。常用的有@param @return等。 2 .跟踪代码依赖性，实现替代配置文件功能，比如Dagger2 依赖注入，未来java开发，将大量注解配置，具有很大好处。 3 .在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。 三、注解的原理? 注解的本质是一个继承了Annotation的特殊接口，其具体实现类是JAVA运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。 四、元注解? java.lang.annotation提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要用到元注解）：@Documented 注解是否将包含在javaDoc中@Retention –什么时候使用该注解@Target –注解用于什么地方@Inherited – 是否允许子类继承该注解 1.）@Retention– 定义该注解的生命周期 ● RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 ● RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式 ● RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 2.）Target – 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType参数包括 ● ElementType.CONSTRUCTOR:用于描述构造器 ● ElementType.FIELD:成员变量、对象、属性（包括enum实例） ● ElementType.LOCAL_VARIABLE:用于描述局部变量 ● ElementType.METHOD:用于描述方法 ● ElementType.PACKAGE:用于描述包 ● ElementType.PARAMETER:用于描述参数 ● ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明 3.)@Documented–一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。 4.)@Inherited – 定义该注释和子类的关系 @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 五、常见标准的Annotation：1.）Override java.lang.Override是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。 2.）Deprecated Deprecated也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员， 虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。 3.)SuppressWarnings SuppressWarning不是一个标记类型注解。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。 @SuppressWarnings(&quot;unchecked&quot;)。 六、自定义注解?自定义注解类编写的一些规则: 1. Annotation型定义为@interface, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口. 2. 参数成员只能用public或默认(default)这两个访问权修饰 3. 参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String、Enum、Class、annotations等数据类型,以及这一些类型的数组. 4. 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法 5. 注解也可以没有定义成员, 不过这样注解就没啥用了。 PS:自定义注解需要使用到元注解 七、自定义注解实例？ FruitName:java","categories":[{"name":"Java","slug":"Java","permalink":"http://hanusers.gitee.io/categories/Java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://hanusers.gitee.io/tags/注解/"}]},{"title":"SpringBoot","slug":"springboot","date":"2018-07-16T09:39:37.000Z","updated":"2018-11-27T02:58:06.225Z","comments":true,"path":"2018/07/16/springboot/","link":"","permalink":"http://hanusers.gitee.io/2018/07/16/springboot/","excerpt":"","text":"SpringBoot概述 Build Anything with Spring Boot：Spring Boot is the starting point for building all Spring-based applications.Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring. 上面是引自Spring官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。 追问一: SpringBoot是什么，它可以做什么? 在过去的两年时间里，最让人兴奋、回头率最高、最能改变游戏规则的东西，大概就是Spring Boot了。Spring Boot提供了一种新的编程范式，能在最小的阻力下开发Spring应用程序。有了它， 你可以更加敏捷地开发Spring应用程序，专注于应用程序的功能，不用在Spring的配置上多花功夫，甚至完全不用配置。实际上，Spring Boot的一项重要工作就是让Spring配置不再成为你成功路上的绊脚石。 搜狗百科 Spring Boot Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者 SpringBoot的一些解释SpringBoot与SpringMvc的关系:SpringBoot是SpringMvc的升级版，抛弃掉SpringMvc的大量的xml中的配置项. SpringBoot的一些特点. 1.化繁为简，简化配置. 2.备受关注,是下一代框架. 3.微服务的入门级微框架，（微服务:SpringCloud）Spring家族的微服务。Spring-Data-Jpa: JPA(java persistence API):定义了一系列对象持久化的标准，目前实现这一规范的产品有Hibernate TopLink等 SpringBoot项目整体结构图一:图二:","categories":[{"name":"Java","slug":"Java","permalink":"http://hanusers.gitee.io/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://hanusers.gitee.io/tags/SpringBoot/"}]},{"title":"介绍Spring","slug":"20180712001","date":"2018-07-12T06:39:15.000Z","updated":"2021-06-02T08:23:28.301Z","comments":true,"path":"2018/07/12/20180712001/","link":"","permalink":"http://hanusers.gitee.io/2018/07/12/20180712001/","excerpt":"","text":"一. 什么是Spring? Spring是一个框架,是一个j2EE应用程序框架,是轻量级的IOC和AOP的容器框架,主要是针对JavaBean的生命周期进行管理的轻量级容器,可以单独使用, 也可以与Struts框架,mybatis等ORM框架使用. 二.Spring架构概述. 上图就是spring框架的整体概述,包含框架的模块组成部分,下面要聊聊关于Spring的那些事. spring的核心问题,只有掌握了这些核心原理,才能在工作中会使用spring框架, 并正确根据接口需求配置spring框架. 1)IOC IOC(Inversio of Control) 控制反转,对象创建责任的反转,把创建对象的控制权由人转变为工厂.在Sping中BeanFactory是IOC容器的的核心接口,负责实例化,定位,配置应用程序中的对象及建立这些对象间的依赖,XMLBeanFactory实现BeanFactory接口,通过获取xml配置文件数据,组成应用对象及对象间的依赖关系. Spring有三种注入方式,一种是set注入,一种是接口注入,另一种是构造方法注入. 2)AOP Aop是纵向的编程,比如: 业务1和业务2都需要一个相同的操作,与其往每个业务中都添加同样的代码.不如写一遍代码,让两个业务共同使用这段代码. spring中面向切面编程实现有两种方式,一种是动态代理,一种是CGLIB 动态代理必须提供接口,而CGLiB实现是有继承. 三.为什么使用Spring框架!在不使用spring框架之前,我们的service层中要使用到层的对象,不得不在service层中new一个对象.如下:`//dao层对象public class UserDao{public insert(User user){}} //service层对象public classUserService{ public void insert(User user){ UserDao userDao=new UserDao(); userDao.insert(user); }} 以上代码存的问题: 层与层之间的依赖. 使用框架后: //dao层对象 public class UserDao{ public void insert(User user){} } //service层对象 public classUserService{ @Autowird(通过注解告诉工厂创建bean对象) private UserDao userDao; public void insert(User user){ userDao.insert(user); } //getUserdao public UserDao getUserDao(){ return userDao; } public void setUserdao(UserDao userDao){ this.userDao=userDao; } }`service层要用dao层对象需要配置到xml配置文件中,至于对象是怎么创建的,关系是怎么组合的都交给了spring框架去实现的.(框架其实是利用了反射的原理创建的对象). 四. 框架优点. 轻量级的框架没有侵入性. 使用ioc容器更加容易组合对象直接间关系,面向接口编程.降低耦合. Aop可以更加容易的进行功能扩展,遵循OCP开发原则. 创建对象默认是单例的,不需要再单独使用单例模式进行处理. 五. 缺点 业务功能依赖spring特有的功能,依赖与spring环境。。。。。六. 整合Spring完整的提供了和ORM框架的整合方案和接口支持。…………….","categories":[{"name":"Spring","slug":"Spring","permalink":"http://hanusers.gitee.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://hanusers.gitee.io/tags/Spring/"}]}]}